<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Translation Workbench — {{ project }}</title>
<!-- Version 1.12 - On-demand concordance loading, TMX as single source of truth -->
<style>
/* --- Layout and spacing --- */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
}

#topbar {
  background: #eee;
  padding: 10px;
  display: flex;
  align-items: center;
  gap: 10px;
}

#main {
  display: flex;
  height: calc(100vh - 50px);
  overflow: hidden;
  max-width: 100vw;
  padding: 0 20px;
  box-sizing: border-box;
}

/* --- Sticky panel headers --- */
.panel-header {
  position: sticky;
  top: 0;
  background: #fff;
  z-index: 10;
  padding: 10px;
  border-bottom: 1px solid #ddd;
}

.panel-header h2 {
  margin: 0;
}

#lemma-search {
  margin-top: 6px;
  width: 100%;
  padding: 4px 6px;
  font-size: 0.9em;
  box-sizing: border-box;
}

/* --- Editor and Reference Panels --- */
#editor-panel,
#reference-panel {
  flex: 0 0 auto;
  flex-shrink: 0;
  flex-grow: 0;
  overflow-y: auto;
  padding: 0;
}

#editor-panel {
  width: calc(50% - 2.5px - 20px);
  background: #fff;
  min-width: 100px;
  overflow-x: hidden;
}

#reference-panel {
  width: calc(50% - 2.5px - 20px);
  background: #fff;
  border-left: 1px solid #ccc;
  box-sizing: border-box;
}

/* --- Scrollable content padding --- */
#segments-container,
#lemmas-container {
  padding: 10px;
}

/* --- Divider --- */
#divider {
  width: 5px;
  cursor: col-resize;
  background-color: #ccc;
  flex: 0 0 auto;
}

/* --- Editor & Concordance Elements --- */
.segment {
  margin-bottom: 5px;
  padding-bottom: 5px;
  border-bottom: none;
}

.segment.paragraph-break {
  border-bottom: 1px solid #ddd;
  margin-bottom: 15px;
  padding-bottom: 10px;
}

.segment-row {
  display: table;
  width: 100%;
  table-layout: fixed;
  margin-bottom: 2px;
}

.segment-text {
  display: table-cell;
  vertical-align: top;
  padding-right: 5px;
}

.segment-arrow {
  display: table-cell;
  vertical-align: top;
  width: 30px;
  text-align: right;
}

.source-preview {
  margin-bottom: 5px;
}

.source {
  background-color: #fff;
  display: inline;
  padding: 0 2px;
}

.target {
  background-color: #CDE0CC;
  display: block;
  padding: 2px;
  margin-top: 2px;
  min-height: 1.2em;
  outline: none;
  border: none;
}

.lemma-row {
  cursor: pointer;
  padding: 2px 0;
}

/* --- Concordance table containment --- */
.concordance {
  display: block;
  margin-top: 5px;
  width: 100%;
  overflow: hidden;
  box-sizing: border-box;
}

.concordance table {
  width: 100%;
  table-layout: fixed;
  border-collapse: collapse;
}

.concordance th,
.concordance td {
  max-width: 100%;
  word-break: break-word;
  white-space: normal;
}

/* --- Misc --- */
.bold-word {
  font-weight: bold;
}

.source-word {
  cursor: pointer;
}

.source-word.suppressed-lemma {
  cursor: default;
}

.pos-select {
  font-size: 0.8em;
  margin-left: 2px;
}

.parse-btn {
  color: #bbb;
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  font-size: 1em;
  margin-left: 5px;
}

/* --- Lemma meanings --- */
.lemma-meaning {
  display: inline-block;
  max-width: 300px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: top;
}

.lemma-meaning.expanded {
  white-space: normal;
}

.naob-edit,
.meaning-edit {
  color: #bbb;
}

.pos-tag {
  color: #bbb;
}

.lemma-row.suppressed {
  background-color: #f0f0f0;
}

/* V1.8: Loading indicator */
.loading-indicator {
  text-align: center;
  padding: 20px;
  color: #666;
  font-style: italic;
}

/* V1.12: Google Translate arrow */
.translate-arrow {
  color: #bbb;
  cursor: pointer;
  margin-left: 5px;
}

.translate-arrow:hover {
  color: #666;
}

.naob-link {
  color: #53557C;
  text-decoration: none;  /* optional: remove underline */
}

.naob-link:hover {
  color: #53557C;
  text-decoration: underline;  /* optional: underline on hover */
}

.naob-link:visited {
  color: #53557C;  /* keep same color after clicking */
}
</style>
</head>
<body>

<div id="topbar">
  <label for="project-select">Project:</label>
  <select id="project-select" aria-label="Current project">
    <option value="{{ project }}">{{ project }}</option>
  </select>
  <a href="/dashboard/{{ project }}" style="margin-left:10px;">Dashboard</a>
  <a href="/" style="margin-left:10px;">Projects</a>
</div>

<div id="main">
  {% include "components/editor_panel.html" %}
  <div id="divider"></div>
  {% include "components/reference_panel.html" %}
</div>
<script>
// ---------- Layout slider ----------
const divider = document.getElementById("divider");
const leftPanel = document.getElementById("editor-panel");
const rightPanel = document.getElementById("reference-panel");
const container = leftPanel.parentNode;

divider.addEventListener("mousedown", (e) => {
    e.preventDefault();
    const startX = e.clientX;
    const startLeftWidth = leftPanel.offsetWidth;
    const startRightWidth = rightPanel.offsetWidth;

    function onMouseMove(e) {
        const dx = e.clientX - startX;
        let newLeftWidth = startLeftWidth + dx;
        let newRightWidth = startRightWidth - dx;

        if (newLeftWidth < 100) {
            newLeftWidth = 100;
            newRightWidth = container.offsetWidth - newLeftWidth - divider.offsetWidth;
        }
        if (newRightWidth < 100) {
            newRightWidth = 100;
            newLeftWidth = container.offsetWidth - newRightWidth - divider.offsetWidth;
        }

        leftPanel.style.width = `${newLeftWidth}px`;
        rightPanel.style.width = `${newRightWidth}px`;
    }

    function onMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
    }

    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
});

// ---------- Global state ----------
window.manualPOS = {};
window.lemmaData = {};
window.naobOverrides = {};
window.meanings = {};
window.suppressions = {pos: [], lemmas: []};
window.segments = [];  // V1.4: ALL segments for concordance lookups
window.editorSegments = [];  // V1.4: Currently displayed segments in editor

// ---------- Helpers ----------
function escapeHtml(text) {
    return (text || "").replace(/[&<>"']/g, (m) => ({
        '&':'&amp;',
        '<':'&lt;',
        '>':'&gt;',
        '"':'&quot;',
        "'":'&#039;'
    }[m]));
}

function capitalizeFirst(text) {
    if (!text) return text;
    return text.charAt(0).toUpperCase() + text.slice(1);
}

function normalizeWord(word) {
    return (word || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g,'')
        .replace(/[^a-zA-ZåøæÅØÆ]/g,'')
        .toLowerCase()
        .trim();
}

// ---------- Reference panel partial refresh ----------
function refreshReferencePanel() {
    const currentProject = "{{ project }}";
    fetch(`/project/${currentProject}`)
        .then(res => res.json())
        .then(data => {
            window.lemmaData = data.lemmas || {};
            window.naobOverrides = data.naob_overrides || {};
            window.meanings = data.meanings || {};
            window.suppressions = data.suppressions || {pos: [], lemmas: []};
            renderReference(window.lemmaData);
        });
}

// ---------- Editor rendering ----------
function wrapWordsForPreview(segment) {
    return segment.tokens.map((token, i) => {
        const pos = token.pos === "PUNCT"
            ? "PUNCT"
            : (window.manualPOS[segment.id]?.[i] || token.pos);

        const lemmaKey = `${token.lemma}|${pos}`;
        const isSuppressed = window.suppressions.lemmas.includes(lemmaKey) || 
                           window.suppressions.pos.includes(pos);
        const suppressedClass = isSuppressed ? ' suppressed-lemma' : '';

        return `<span class="source-word${suppressedClass}"
                     data-lemma="${escapeHtml(token.lemma)}"
                     data-pos="${pos}"
                     data-index="${i}">
                     ${escapeHtml(token.text)}
                </span>`;
    }).join(' ');
}

function renderEditor(segments) {
    window.editorSegments = segments;  // V1.4: Store editor-specific segments
    const container = document.getElementById("segments-container");
    container.innerHTML = "";

    for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        const segDiv = document.createElement("div");
        segDiv.className = "segment";
        segDiv.dataset.segmentId = seg.id;

        if (seg.is_paragraph_end) segDiv.classList.add("paragraph-break");

        segDiv.innerHTML = `
            <div class="segment-row">
                <div class="segment-text">
                    <div class="source-preview source">${wrapWordsForPreview(seg)}</div>
                    <div class="source-parsed source" style="display:none;"></div>
                </div>
                <div class="segment-arrow">
                    <button type="button" class="parse-btn">▲</button>
                </div>
            </div>
            <div class="segment-row">
                <div class="segment-text">
                    <div class="target"
                         contenteditable="true"
                         data-segment-id="${seg.id}">${seg.target || ""}</div>
                </div>
                <div class="segment-arrow">
                    <span class="translate-arrow" data-source="${escapeHtml(seg.source)}" title="Google Translate">▲</span>
                </div>
            </div>
        `;
        container.appendChild(segDiv);
    }

    container.querySelectorAll(".parse-btn").forEach(btn => {
        btn.addEventListener("click", () => {
            btn.blur();

            const segDiv = btn.closest(".segment");
            const parsedDiv = segDiv.querySelector(".source-parsed");
            const previewDiv = segDiv.querySelector(".source-preview");
            const segId = segDiv.dataset.segmentId;

            const previewSpans = previewDiv.querySelectorAll(".source-word");
            const tokens = Array.from(previewSpans).map(sp => ({
                text: sp.innerText,
                lemma: sp.dataset.lemma || normalizeWord(sp.innerText),
                pos: sp.dataset.pos || "UNK"
            }));

            parsedDiv.innerHTML = tokens.map((token, i) => {
                const pos = token.pos === "PUNCT"
                    ? "PUNCT"
                    : (window.manualPOS[segId]?.[i] || token.pos);

                const posTag = (pos === "PUNCT") ? "" : ` <span class="pos-tag">(${escapeHtml(pos)})</span>`;

                const lemmaKey = `${token.lemma}|${pos}`;
                const isSuppressed = window.suppressions.lemmas.includes(lemmaKey) || 
                                   window.suppressions.pos.includes(pos);
                const suppressedClass = isSuppressed ? ' suppressed-lemma' : '';

                return `<span class="source-word${suppressedClass}"
                             data-lemma="${escapeHtml(token.lemma)}"
                             data-pos="${pos}"
                             data-index="${i}">
                             ${escapeHtml(token.text)}${posTag}
                        </span>`;
            }).join(' ');

            parsedDiv.style.display = "block";
            previewDiv.style.display = "none";
            btn.style.display = "none";

            addEditorWordListeners();
        });
    });

    container.querySelectorAll(".source-parsed").forEach(parsedDiv => {
        parsedDiv.addEventListener("click", () => {
            const segDiv = parsedDiv.closest(".segment");
            const previewDiv = segDiv.querySelector(".source-preview");
            const btn = segDiv.querySelector(".parse-btn");

            parsedDiv.style.display = "none";
            previewDiv.style.display = "inline";
            btn.style.display = "inline";
        });
    });

    // V1.12: Google Translate arrow handlers
    container.querySelectorAll(".translate-arrow").forEach(arrow => {
        arrow.addEventListener("click", () => {
            const sourceText = arrow.dataset.source;
            if (!sourceText) return;
            
            // Encode source text into Google Translate URL
            const encodedText = encodeURIComponent(sourceText);
            const translateUrl = `https://translate.google.co.uk/?sl=no&tl=en&text=${encodedText}&op=translate`;
            
            // Open Google Translate in new window with text pre-filled
            const width = window.innerWidth / 2;
            const height = window.innerHeight;
            window.open(
                translateUrl,
                'GoogleTranslate',
                `width=${width},height=${height}`
            );
        });
    });

    const PROJECT_NAME = "{{ project }}";
    const targets = Array.from(document.querySelectorAll(".target"));

    targets.forEach((target, idx) => {
        target.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                const segmentId = target.dataset.segmentId;
                const text = target.innerText;

                fetch(`/project/${encodeURIComponent(PROJECT_NAME)}/update_segment`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ segment_id: segmentId, target_text: text })
                }).then(res => {
                    if (res.ok) {
                        // V1.12: Update local segments cache (TMX source of truth)
                        const segment = window.segments.find(s => s.id === segmentId);
                        if (segment) {
                            segment.target = text;
                        }
                        
                        // ✅ V1.1: Update all visible concordance cells
                        document.querySelectorAll(`td[data-segment-id="${segmentId}"][contenteditable="true"]`).forEach(cell => {
                            if (cell !== document.activeElement) {
                                cell.innerText = text;
                            }
                        });
                        
                        const nextTarget = targets[idx + 1];
                        if (nextTarget) {
                            nextTarget.focus();
                            const range = document.createRange();
                            const sel = window.getSelection();
                            range.selectNodeContents(nextTarget);
                            range.collapse(false);
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                    }
                });
            }
        });
    });

    container.addEventListener("click", e => {
        const span = e.target.closest(".source-word");
        if (!span) return;
        if (span.classList.contains("suppressed-lemma")) return;
        
        const lemma = span.dataset.lemma;
        const pos = span.dataset.pos;
        const lemmaKey = `${lemma}|${pos}`;
        
        const foundKey = findLemmaKeyForWord(span.innerText);
        if (foundKey) openLemmaAndScroll(foundKey);
    });
}

// ---------- Reference rendering ----------
function renderReference(lemmas) {
    const container = document.getElementById("lemmas-container");
    const lemmaEntries = Object.entries(lemmas);
    const total = lemmaEntries.length;
    
    // V1.7: Show progress during rendering
    container.innerHTML = `<div style="padding: 20px; text-align: center;">
        <div>Rendering reference panel...</div>
        <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
            <span id="render-progress">0</span>/${total} lemmas
        </div>
        <div style="width: 100%; background: #ddd; height: 20px; border-radius: 10px; overflow: hidden; margin-top: 10px;">
            <div id="render-progress-bar" style="width: 0%; background: #4CAF50; height: 100%;"></div>
        </div>
    </div>`;
    
    const batchSize = 50;  // Render 50 lemmas at a time
    let currentIndex = 0;
    
    function renderBatch() {
        const endIndex = Math.min(currentIndex + batchSize, total);
        const fragment = document.createDocumentFragment();
        
        for (let i = currentIndex; i < endIndex; i++) {
            const [key, data] = lemmaEntries[i];
            const div = createLemmaRowElement(key, data);
            fragment.appendChild(div);
        }
        
        // First batch - clear container and start adding
        if (currentIndex === 0) {
            container.innerHTML = '';
        }
        
        container.appendChild(fragment);
        currentIndex = endIndex;
        
        // Update progress
        const percent = Math.round((currentIndex / total) * 100);
        const progressBar = document.getElementById('render-progress-bar');
        const progressText = document.getElementById('render-progress');
        
        if (progressBar) progressBar.style.width = percent + '%';
        if (progressText) progressText.textContent = currentIndex;
        
        // Continue rendering or finish
        if (currentIndex < total) {
            requestAnimationFrame(renderBatch);
        } else {
            // Remove progress indicator if it still exists
            const progressDiv = container.querySelector('div[style*="padding: 20px"]');
            if (progressDiv) progressDiv.remove();
        }
    }
    
    // Start rendering
    requestAnimationFrame(renderBatch);
}

// ✅ V1.1: Helper to create a single lemma row element
function createLemmaRowElement(key, data) {
    const div = document.createElement("div");
    div.className = "lemma-row";

    const defaultUrl = `https://naob.no/ordbok/${encodeURIComponent(data.lemma)}`;
    const finalUrl = window.naobOverrides[key] || defaultUrl;

    const meaningText = window.meanings[key] || "";

    const isSuppressed = window.suppressions.lemmas.includes(key) || 
                       window.suppressions.pos.includes(data.pos);

    if (isSuppressed) {
        div.classList.add("suppressed");
    }

    const displayLemma = (data.pos === 'PROPN') ? capitalizeFirst(data.lemma) : data.lemma;
    const displayWordforms = (data.pos === 'PROPN')
        ? data.wordforms.map(wf => capitalizeFirst(wf)).join(", ")
        : data.wordforms.join(", ");

    div.innerHTML = `
        <strong>${escapeHtml(displayLemma)}</strong>
        <span class="pos-tag">(${escapeHtml(data.pos)})</span> |
        ${escapeHtml(displayWordforms)} |
        <span class="naob-edit" style="cursor:pointer;margin-right:4px;">▲</span>
        <a href="#" class="naob-link">NAOB</a>
        |
        <span class="meaning-edit" style="cursor:pointer;margin-right:4px;">▲</span>
        <span class="lemma-meaning" title="${escapeHtml(meaningText)}">${escapeHtml(meaningText)}</span>
        <div class="concordance" id="concordance-${encodeURIComponent(key)}"></div>
    `;

    // ✅ V1.1: Add click handler for NAOB link that uses current URL from window.naobOverrides
    const naobLink = div.querySelector(".naob-link");
    naobLink.addEventListener("click", (e) => {
        e.preventDefault();
        const currentUrl = window.naobOverrides[key] || `https://naob.no/ordbok/${encodeURIComponent(data.lemma)}`;
        window.open(currentUrl, 'NAOB', 'width=' + window.innerWidth/2 + ',height=' + window.innerHeight);
    });

    const editBtn = div.querySelector(".naob-edit");
    editBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();

        const input = document.createElement("input");
        input.type = "text";
        input.value = window.naobOverrides[key] || "";
        input.style.width = "90%";

        editBtn.replaceWith(input);
        input.focus();
        input.select();

        input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                saveNaobOverride(key, input.value);
            }
            if (e.key === "Escape") {
                renderSingleLemmaRow(key);
            }
        });

        input.addEventListener("blur", () => {
            renderSingleLemmaRow(key);
        });
    });

    const meaningEditBtn = div.querySelector(".meaning-edit");
    const meaningSpan = div.querySelector(".lemma-meaning");

    meaningEditBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();

        const textarea = document.createElement("textarea");
        textarea.value = window.meanings[key] || "";
        textarea.style.width = "90%";
        textarea.rows = 2;

        meaningSpan.replaceWith(textarea);
        textarea.focus();
        textarea.select();

        textarea.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                saveMeaning(key, textarea.value);
            }
            if (e.key === "Escape") {
                renderSingleLemmaRow(key);
            }
        });

        textarea.addEventListener("blur", () => {
            saveMeaning(key, textarea.value);
        });
    });

    if (meaningSpan) {
        meaningSpan.addEventListener("mouseenter", () => {
            meaningSpan.classList.add("expanded");
        });
        meaningSpan.addEventListener("mouseleave", () => {
            meaningSpan.classList.remove("expanded");
        });
    }

    div.addEventListener("click", (ev) => {
        if (ev.target.tagName.toLowerCase() === "a") return;
        if (ev.target.classList.contains("naob-edit")) return;
        if (ev.target.classList.contains("meaning-edit")) return;
        if (!isSuppressed) {
            openLemmaAndScroll(key);
        }
    });

    return div;
}

// ✅ V1.1: Re-render a single lemma row
function renderSingleLemmaRow(lemmaKey) {
    const data = window.lemmaData[lemmaKey];
    if (!data) return;
    
    // Find the existing lemma row
    const lemmaRows = Array.from(document.querySelectorAll(".lemma-row"));
    const existingRow = lemmaRows.find(div => {
        const strong = div.querySelector("strong");
        return strong && normalizeWord(strong.innerText) === normalizeWord(data.lemma);
    });
    
    if (!existingRow) return;
    
    // Check if concordance is currently open
    const concordanceDiv = existingRow.querySelector('.concordance');
    const wasOpen = concordanceDiv && concordanceDiv.style.display === "block";
    
    // Create new row
    const newRow = createLemmaRowElement(lemmaKey, data);
    
    // Replace old row with new row
    existingRow.replaceWith(newRow);
    
    // Re-open concordance if it was open
    if (wasOpen) {
        openLemmaAndScroll(lemmaKey);
    }
}

// ---------- Save NAOB override ----------
function saveNaobOverride(lemmaKey, url) {
    const project = "{{ project }}";
    
    // ✅ V1.1: Normalize URL to match backend normalization
    let normalizedUrl = (url || "").trim();
    if (!normalizedUrl) {
        // If empty, keep it empty
        normalizedUrl = "";
    } else if (!normalizedUrl.startsWith("http://") && !normalizedUrl.startsWith("https://")) {
        normalizedUrl = "https://" + normalizedUrl;
    }

    fetch(`/project/${project}/set_naob_override`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            lemma_key: lemmaKey,
            url: url  // Send original URL, backend will normalize
        })
    }).then(res => {
        if (res.ok) {
            // ✅ V1.1: Update local state with normalized URL
            window.naobOverrides[lemmaKey] = normalizedUrl;
            renderSingleLemmaRow(lemmaKey);
        }
    });
}

// ---------- Save meaning ----------
function saveMeaning(lemmaKey, meaning) {
    const project = "{{ project }}";

    fetch(`/project/${project}/set_meaning`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            lemma_key: lemmaKey,
            meaning: meaning
        })
    }).then(res => {
        if (res.ok) {
            // ✅ V1.1: Just update local state and re-render this one row
            window.meanings[lemmaKey] = meaning;
            renderSingleLemmaRow(lemmaKey);
        }
    });
}

// ---------- Concordance ----------
async function toggleConcordance(key, occurrences) {
    const lemmaData = window.lemmaData[key];
    if (!lemmaData) return;
    
    const isSuppressed = window.suppressions.lemmas.includes(key) || 
                       window.suppressions.pos.includes(lemmaData.pos);
    
    if (isSuppressed) {
        return;
    }

    document.querySelectorAll(".concordance").forEach(div => {
        if (div.id !== `concordance-${encodeURIComponent(key)}`) div.style.display = "none";
    });

    const concordanceDiv = document.getElementById(`concordance-${encodeURIComponent(key)}`);
    if (!concordanceDiv) return;

    if (concordanceDiv.style.display === "block") { 
        concordanceDiv.style.display = "none"; 
        return; 
    }

    concordanceDiv.style.display = "block";

    concordanceDiv.innerHTML = "";
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.tableLayout = "fixed";
    table.border = "1";

    const header = document.createElement("tr");
    header.innerHTML = `
        <th style="width: 50%;">Source</th>
        <th style="width: 50%;">Target</th>
    `;
    table.appendChild(header);

    const grouped = {};
    occurrences.forEach(occ => {
        if (!grouped[occ.source_segment]) grouped[occ.source_segment] = [];
        grouped[occ.source_segment].push(occ);
    });

    const lemmaWordforms = lemmaData ? lemmaData.wordforms : [];
    const normalizedWordforms = lemmaWordforms.map(wf => normalizeWord(wf));

    Object.keys(grouped).forEach(sourceText => {
        const tr = document.createElement("tr");
        const srcTd = document.createElement("td");
        const tgtTd = document.createElement("td");
        
        const segmentId = grouped[sourceText][0].segment_id;
        tgtTd.contentEditable = "true";
        tgtTd.dataset.segmentId = segmentId;
        // V1.12: Get target from window.segments (TMX source of truth)
        const segment = window.segments.find(s => s.id === segmentId);
        tgtTd.innerText = segment ? segment.target : "";

        tgtTd.addEventListener("click", (e) => {
            e.stopPropagation();
        });

        tgtTd.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                const targetText = tgtTd.innerText;
                const currentProject = "{{ project }}";
                
                fetch(`/project/${encodeURIComponent(currentProject)}/update_segment`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ segment_id: segmentId, target_text: targetText })
                }).then(res => {
                    if (res.ok) {
                        // V1.12: Update local segments cache (TMX source of truth)
                        const segment = window.segments.find(s => s.id === segmentId);
                        if (segment) {
                            segment.target = targetText;
                        }
                        
                        // ✅ V1.1: Update all visible concordance cells
                        document.querySelectorAll(`td[data-segment-id="${segmentId}"][contenteditable="true"]`).forEach(cell => {
                            if (cell !== document.activeElement) {
                                cell.innerText = targetText;
                            }
                        });
                        
                        // ✅ V1.1: Update editor panel target
                        const editorTarget = document.querySelector(`.target[data-segment-id="${segmentId}"]`);
                        if (editorTarget && editorTarget !== document.activeElement) {
                            editorTarget.innerText = targetText;
                        }
                    }
                });
            }
        });

        if (segment && segment.tokens) {
            srcTd.innerHTML = segment.tokens.map((token, i) => {
                const pos = token.pos === "PUNCT"
                    ? "PUNCT"
                    : (window.manualPOS[segmentId]?.[i] || token.pos);
                
                const lemmaKey = `${token.lemma}|${pos}`;
                const isSuppressed = window.suppressions.lemmas.includes(lemmaKey) || 
                                   window.suppressions.pos.includes(pos);
                const suppressedClass = isSuppressed ? ' suppressed-lemma' : '';
                
                const isMatch = normalizedWordforms.includes(normalizeWord(token.text));
                const bgStyle = isMatch ? ' style="background-color: #e0e0e0;"' : '';

                return `<span class="source-word${suppressedClass}"
                             data-lemma="${escapeHtml(token.lemma)}"
                             data-pos="${pos}"
                             data-index="${i}"${bgStyle}>
                             ${escapeHtml(token.text)}
                        </span>`;
            }).join(' ');
        } else {
            srcTd.innerText = sourceText;
        }

        tr.appendChild(srcTd);
        tr.appendChild(tgtTd);
        table.appendChild(tr);
    });

    concordanceDiv.appendChild(table);
    concordanceDiv.style.display = "block";

    concordanceDiv.addEventListener("click", function(ev) {
        const span = ev.target.closest(".source-word");
        if (!span) return;
        if (span.classList.contains("suppressed-lemma")) return;

        const lemma = span.dataset.lemma;
        const pos = span.dataset.pos;
        const tempLemmaKey = `${lemma}|${pos}`;
        
        if (!tempLemmaKey || !window.lemmaData[tempLemmaKey]) return;

        document.querySelectorAll(".concordance").forEach(div => div.style.display = "none");
        setTimeout(() => { openLemmaAndScroll(tempLemmaKey); }, 0);
    });
}

// ---------- Lemma lookup ----------
function findLemmaKeyForWord(word) {
    const normalized = normalizeWord(word);
    for (let k of Object.keys(window.lemmaData || {})) {
        const data = window.lemmaData[k];
        if (!data) continue;
        if (normalizeWord(data.lemma) === normalized) return k;
        for (let wf of (data.wordforms || []))
            if (normalizeWord(wf) === normalized) return k;
    }
    return null;
}

function findLemmaKeyByWordform(query) {
    const normalized = normalizeWord(query);
    if (!normalized) return null;

    for (let [key, data] of Object.entries(window.lemmaData || {})) {
        for (let wf of (data.wordforms || [])) {
            if (normalizeWord(wf) === normalized) return key;
        }
    }
    return null;
}

// ---------- Jump ----------
function clearLemmaSearch() {
    const input = document.getElementById("lemma-search");
    if (input) input.value = "";
}

async function openLemmaAndScroll(lemmaKey) {
    clearLemmaSearch();
    const data = window.lemmaData?.[lemmaKey];
    if (!data) return;

    // V1.12: Fetch concordances on-demand
    const project = "{{ project }}";
    try {
        const response = await fetch(`/project/${encodeURIComponent(project)}/lemma/${encodeURIComponent(lemmaKey)}/concordances`);
        if (!response.ok) {
            console.error('Failed to fetch concordances');
            return;
        }
        const concordanceData = await response.json();
        
        // Pass fetched occurrences to existing function
        toggleConcordance(lemmaKey, concordanceData.occurrences);
    } catch (err) {
        console.error('Error fetching concordances:', err);
        return;
    }

    const lemmaRows = Array.from(document.querySelectorAll(".lemma-row"));
    const lemmaDiv = lemmaRows.find(div => {
        const strong = div.querySelector("strong");
        return strong && normalizeWord(strong.innerText) === normalizeWord(data.lemma);
    });

    if (lemmaDiv) {
        lemmaDiv.scrollIntoView({ behavior: "smooth", block: "center" });
    }
}

// ---------- Reference search ----------
function setupLemmaSearch() {
    const searchInput = document.getElementById("lemma-search");
    if (!searchInput || searchInput.dataset.bound) return;
    searchInput.dataset.bound = "1";

    searchInput.addEventListener("keydown", (e) => {
        if (e.key !== "Enter") return;
        e.preventDefault();

        const lemmaKey = findLemmaKeyByWordform(searchInput.value);
        if (!lemmaKey) {
            searchInput.style.backgroundColor = "#ffd6d6";
            setTimeout(() => searchInput.style.backgroundColor = "", 400);
            return;
        }

        openLemmaAndScroll(lemmaKey);
    });

    searchInput.addEventListener("dblclick", () => {
        const lemmaKey = findLemmaKeyByWordform(searchInput.value);
        if (lemmaKey) openLemmaAndScroll(lemmaKey);
    });
}

// ---------- Autosuggestions ----------
function updateLemmaSearchSuggestions(prefix) {
    const datalist = document.getElementById("lemma-wordform-list");
    if (!datalist) return;

    datalist.innerHTML = "";

    const normalizedPrefix = normalizeWord(prefix);
    if (normalizedPrefix.length < 3) return;

    const seen = new Set();

    for (const data of Object.values(window.lemmaData || {})) {
        for (const wf of (data.wordforms || [])) {
            const norm = normalizeWord(wf);
            if (!norm.startsWith(normalizedPrefix)) continue;
            if (seen.has(norm)) continue;
            seen.add(norm);

            const option = document.createElement("option");
            option.value = wf;
            datalist.appendChild(option);
        }
    }
}

function setupLemmaSearchSuggestions() {
    const input = document.getElementById("lemma-search");
    if (!input || input.dataset.suggestBound) return;
    input.dataset.suggestBound = "1";

    input.addEventListener("input", () => {
        updateLemmaSearchSuggestions(input.value);
    });
}

function addEditorWordListeners() {}

// ---------- Init ----------
(function init() {
    const currentProject = "{{ project }}";
    if (currentProject) {
        // V1.8: Show loading indicator
        const lemmasContainer = document.getElementById("lemmas-container");
        lemmasContainer.innerHTML = '<div style="padding: 20px; text-align: center;">Loading project data...</div>';
        
        fetch(`/project/${currentProject}`)
            .then(res => res.json())
            .then(data => {
                lemmasContainer.innerHTML = '<div style="padding: 20px; text-align: center;">Processing lemmas...</div>';
                
                window.lemmaData = data.lemmas || {};
                window.naobOverrides = data.naob_overrides || {};
                window.meanings = data.meanings || {};
                window.suppressions = data.suppressions || {pos: [], lemmas: []};
                
                // V1.5: Store ALL segments with segment-to-file mapping
                window.segments = data.segments || [];
                window.segmentFilesMap = data.segment_files_map || {};
                
                lemmasContainer.innerHTML = '<div style="padding: 20px; text-align: center;">Rendering reference panel...</div>';
                
                // V1.5: Populate source file selector
                const sourceFileSelect = document.getElementById("source-file-select");
                if (sourceFileSelect && data.source_files) {
                    data.source_files.forEach(file => {
                        const option = document.createElement("option");
                        option.value = file;
                        option.textContent = file;
                        sourceFileSelect.appendChild(option);
                    });
                    
                    // V1.5: Auto-select first file if only one
                    if (data.source_files.length === 1) {
                        sourceFileSelect.value = data.source_files[0];
                        filterAndRenderEditor(data.source_files[0]);
                    }
                    
                    // V1.5: Handle source file selection
                    sourceFileSelect.addEventListener("change", (e) => {
                        const selectedFile = e.target.value;
                        if (selectedFile) {
                            filterAndRenderEditor(selectedFile);
                        } else {
                            document.getElementById("segments-container").innerHTML = "Please select a source file...";
                        }
                    });
                }
                
                renderReference(window.lemmaData);
                setupLemmaSearch();
                setupLemmaSearchSuggestions();
            })
            .catch(err => {
                lemmasContainer.innerHTML = '<div style="padding: 20px; color: #f44336;">Error loading project: ' + err.message + '</div>';
            });
    } else {
        setupLemmaSearch();
        setupLemmaSearchSuggestions();
    }
})();

// V1.5: Filter segments locally and render in editor
function filterAndRenderEditor(sourceFile) {
    const filteredSegments = window.segments.filter(seg => {
        return window.segmentFilesMap[seg.id] === sourceFile;
    });
    renderEditor(filteredSegments);
}
</script>
</body>
</html>
